#!/bin/bash

## Load functions to resolve aliases
#. ./resolver

log_start()
{
	echo -n "$@"
	echo -n "$@" >> $logfile

}

log_stop()
{
	echo "$@"
	echo "$@" >> $logfile
}

log()
{
	log_start "$@"
	log_stop ""
}

run()
{
#	log "[CMD] " "$@"
	$@
}

info_start()
{
	log_start '[INFO] '"$@"
}

info_stop()
{
	log_stop "$@"
}

info()
{
	info_start "$@"
	info_stop ""
}

error()
{
	log '[ERROR] '"$@"
}

## Load the variable file, if any, or display an error message and exits
load_variables()
{
	if [ ! -f $script_variables ]
	then
		error Cannot find variables file \"$script_variables\"
		exit 1
	else
		## Load experiment variable data
		. $script_variables
	fi
}

## Returns true if $1 is an integer or a decimal
is_number()
{
	printf %f\\n $1 > /dev/null 2>&1
}

## Returns true if all space-separated elements of $@ (regardless of double quotes) are an integers or decimal value
is_number_seq()
{
	local first="$1"
	shift

	if (( $# > 0 ))
	then

		is_number "$first"
		local head=$?
		is_number_seq $@
		local tail=$?

		return $(($head || $tail))
	else
		is_number "$first"
	fi
}

usage()
{
	echo 
	echo
	echo './start [compile | run] <experiment> [--instance <instance name>]'
	echo '	[--retry [[--number | -n <numbers>] | [--pattern | -p <expression>] | --all] [--retry-only]]'
	echo
	echo "	<experiment>	Space-free, filename-valid string that name a category of the experiment batch being run."
	echo "				The results of all batches of the same category are merge together without any"
	echo "				data to differentiate them. Several experiments of the same category may be run"
	echo "				to generating more data."
	echo "	<instance name>	Space-free, filename-valid string to name a duplication of an experiment within an experiment"
	echo "				category. Current day, and time as obtain by \"'date|tr ' ' _|tr : -\" by default."
	echo "				If no name is given, continues the experiment duplicate previously interrupted, or"
	echo "				begin a new one with a default name. Depending on options, all running instances of an"
	echo "				experiment duplicate are not run again unless their previous run failed."
	echo '	--retry		Run again an experiment duplicate (or any previous duplicate previously  interrupted) but filters'
	echo '				the running instances after some filter given by one of the options --numbers or --pattern'
	echo '	--number	With --retry, expects <numbers>, a list of running instance numbers as given by any batch output'
	echo '				which will be run again even if they alread succeed in a previous run'
	echo "	<number>	Space separated instance numbers to run again as given by a previous run. If more than"
	echo "				one number, they should be protected with simple or double quotes \(\"1 2 3 4\"\)."
	echo '	--pattern	With --retry and an <expression>, run again all running instances that satisfy the expression'
	echo "	<expression>	Bash-format boolean expression that is tested against all variable combinations. If"
	echo "				The expression returns true (the command returns 0), then this experiment instance is"
	echo "				run again. Otherwise (the command returns an non-zero value) this instance is not run."
	echo "				you can use the function match(<variable>, <regex>) that return true if the sed regular"
	echo "				expression <regex> matches the value of the variable <variable> and false otherwise."
	echo '	--retry-only		Only re-run the running instances requested by --numbers or --pattern options. Otherwise'
	echo '				run also all running instances that previously failed or were never run.'
	echo 
	echo "	For more information: https://www.ida.liu.se/~nicme26"
}

cut_head()
{
	echo \(`echo $@|cut -f 1 -d ' ' --complement`\)
}

get_date()
{
	echo `date +%D\ %R:%S`
}

get_date_filename()
{
	date|tr ' ' _|tr : -
}

build_values()
{
	local myvars=
	local next_step=
	eval myvars=\(`echo $@`\)
	eval next_step=`cut_head ${myvars[@]}`
	local var=${myvars[0]}

	var=`eval echo \$\{$var\[\@\]\}`
	for val in ${var[@]}
	do
		## If var is not a numeric variable, then surround its value with double quotes
		if ! is_number_seq ${var[@]}
		then
			val=\"$val\"
		fi

		if [ "x$#" != "x1" ];
		then
			build_values ${next_step[@]}|while read line
			do
				echo $val $line
			done
		else
			echo $val
		fi
	done
}

build_args()
{
	build_values $@ | tr -d '"'
}

count_args()
{
	local arg_count=1
	local myvars=
	eval myvars=\(`echo $@`\)

	for var in ${myvars[@]};
	do
		arg_count=$(($arg_count * $(echo $(eval echo \$\{$var\[\@\]\})|wc -w)))
	done
	echo $arg_count
}

double_quotes()
{
	tr \\\t ' '|tr -s ' '|xargs echo|sed 's/ /","/g'|sed 's/^/"/g'|sed 's/$/"/g'
}

commas()
{
	sed 's/"/"\\\\\"/g'|while read i; do :(){ for i in "$@"; do echo -n $i,; done|sed 's/,$/\n/g'; }; eval : $i; done
}

build_aliases()
{
	## Take as a base the labelling functions snippet
	cat $labels_snippet_filename

	## Begin with a list of columns
	echo "labels = list("

	## Then find aliases for all variables
	for i in ${compile[@]} ${run[@]} $output_columns
	do
		## Only output aliases if this variable has some declared
		if [ "`eval echo '$'labels_$i`" != "" ]
		then
			## Output the column name ready to receive the vector
			echo -en "\t$i = c("

			## Iterate through all pairs (key,label)
			eval echo '$'labels_$i | tr ";" \\\n | xargs -L 1 echo | grep -v ^$ | while read j
			do
				instance="`echo $j | cut -f 1 -d : | xargs echo`"
				label="`echo $j | cut -f 1 -d : --complement | xargs echo`"
				echo -n \\\"$instance\\\" = \\\"$label\\\"', '
			done | rev | cut -f 1 -d ',' --complement | rev | xargs echo -n
			echo "),"
		fi
	done

	## Now add aliases for column names, if any
	if [ "`eval echo '$'labels_columns`" != "" ]
	then
		## Output the column name ready to receive the vector
		echo -en "\tcolumns = c("

		## Iterate through all pairs (key,label)
		eval echo '$'labels_columns | tr ";" \\\n | xargs -L 1 echo | grep -v ^$ | while read j
		do
			instance="`echo $j | cut -f 1 -d : | xargs echo`"
			label="`echo $j | cut -f 1 -d : --complement | xargs echo`"
			echo -n \\\"$instance\\\" = \\\"$label\\\"', '
		done | rev | cut -f 1 -d ',' --complement | rev | xargs echo -n
		echo ")"
	fi
	## Close the list
	echo ")"
}

convert_csv_to_m()
{
	## Return the index of value $1 for variable $2 at index $3
	find_index()
	{
		local value=$1
		local variable=$2
		local index=$3

		## We are in another process context; we need to reload the variable file
		load_variables

		if [ "`eval echo '$'labels_$variable`" != "" ]
		then
			local counter=0
			#echo '$'labels_$variable >&2
			#eval echo '$'labels_$variable >&2
			#eval echo '$'labels_$variable | tr ";" \\\n | xargs -L 1 echo | grep -v ^$ >&2
			while read j
			do
				local instance="`echo $j | cut -f 1 -d : | xargs echo`"
				if [ "$instance" == "$value" ]
				then	
					break
				else
					counter=$(( $counter + 1 ))
				fi
			done < <(eval echo '$'labels_$variable | tr ";" \\\n | xargs -L 1 echo | grep -v ^$)
		else
			local myindex="`echo ${compile[@]} ${run[@]} $output_columns | tr ' ' \\\n | grep -n $variable | cut -f 1 -d :`"
			local counter=0
			while read j
			do
				if [ "$j" == "$value" ]
				then
					break
				else
					counter=$(( $counter + 1 ))
				fi
			done < <(cat $tempfile | cut -f $myindex -d ' ' | sort -V | uniq)
		fi

		echo -n "$counter "
	}

	local input="$1"
	local output="$2"

	## Prepare the environment variable to export to sed's shell environment
	export -f find_index
	export -f load_variables
	export script_variables
	export input
	export tempfile=$temp/convert.$$.tmp

	## Extract a function name from the output filename, for the table to be generated
	local name="`basename $output .m`"
	echo -e $DATA_BEGIN | sed s/$table_name/$name/g > $output

	## Cut the header to create an initial, unfiltered table
	cat $input | tail -n +2 | tr -d '"' | tr ',' ' ' | sed "s/'/\\\'/g" > $temp/convert.$$.tmp
	local counter=1
	## For each variable, see if there is a label defined. If so, change the value to an index using sed
	for i in ${compile[@]} ${run[@]} $output_columns
	do
		## Convert every column for which there is an alias or if it is not a sequence of numbers
		if [ "`eval echo '$'labels_$i`" != "" ] || ! is_number_seq `cat $temp/convert.$$.tmp|cut -f $counter -d ' '`
		then
			if [ "`eval echo '$'labels_$i`" == "" ]
			then
				eval labels_$i=\"`cat $temp/convert.$$.tmp | sed "s/'/\\\'/g" | cut -f $counter -d ' ' | sort -V | uniq | tr \\\n ';'`\"
			fi

			cat $temp/convert.$$.tmp | sed 's/\(\([^ ]\+ \)\{'$(( $counter - 1 ))'\}\)\([^ ]\+\)\([^$]*\)$/echo -n "\1"; bash -c "find_index \3 '$i' '$counter'"; echo \4/e' > $temp/convert.$$.filtered.tmp
			cat $temp/convert.$$.filtered.tmp | sed "s/'/\\\'/g" | tr -s ' ' > $temp/convert.$$.tmp
		fi
		
		counter=$(( $counter + 1 ))
	done
	cat $temp/convert.$$.tmp >> $output
	echo -e $DATA_END >> $output

	echo -e $COLUMNS_BEGIN >> $output
	for i in ${compile[@]} ${run[@]} $output_columns
	do
		echo -n "'"$i"' " | tr '_' ' ' >> $output
	done		
	echo -e $COLUMNS_END >> $output

	echo -e $REF_BEGIN >> $output
	for i in ${compile[@]} ${run[@]} $output_columns
	do
		if [ "`eval echo '$'labels_$i`" != "" ]
		then
			echo -n '{' >> $output
			eval echo '$'labels_$i | tr ";" \\\n | xargs -L 1 echo | grep -v ^$ | while read j
			do
				local instance="`echo $j | cut -f 1 -d : | sed "s/'/"'"'"'"'"'"/g" | xargs echo | sed "s/'/''/g"`"
				echo -n "'"$instance"' " >> $output
			done
			echo -n '} ' >> $output
		else
			echo -n "{} " >> $output
		fi
	done
	echo -e $REF_END >> $output

	echo -e $SYMB_BEGIN >> $output
	for i in ${compile[@]} ${run[@]} $output_columns
	do
		if [ "`eval echo '$'labels_$i`" != "" ]
		then
			echo -n '{' >> $output
			eval echo '$'labels_$i | tr ";" \\\n | xargs -L 1 echo | grep -v ^$ | while read j
			do
				local label="`echo $j | cut -f 1 -d : --complement | sed "s/'/"'"'"'"'"'"/g" | xargs echo | sed "s/'/''/g"`"
				echo -n "'"$label"' " >> $output
			done
			echo -n '} ' >> $output
		else
			echo -n "{} " >> $output
		fi
	done
	echo -e $SYMB_END >> $output

	
}

merge_dir()
{
	local output_file="$1"
	shift

	info Merging all results to $output_file

	## Take all column name and double quote them
	echo ${compile[@]} ${run[@]} $output_columns | double_quotes > $output_file
	while [ "$#" != "0" ]
	do
		local input_dir=$1

		## Process this argument only if it is a directory
		if [ -d $input_dir ]
		then
			local counter=1
			while read flags
			do
				while read args
				do
					filename=$input_dir/${output_base}_$(echo $flags $args|tr ' ' _|tr -d '"')_${output_success}${output_extension}
					if [ -f ${filename} ]
					then
						cat $filename | tail -n +2 | sed "s/^/`echo $flags $args|commas`,/g" >> $output_file
					fi
				done < <(build_values ${run[@]})
			done < <(build_values ${compile[@]})
		fi
	
		shift
	done
}

compile()
{
	local total_instances=`count_args ${compile[@]}`

        ## Do not do anything if there is no instance to compile
        if [ "$total_instances" == "0" ]
        then
                exit 0
        fi

	info Will compile $total_instances settings

	local compile_counter=1

	# Success
	local compile_success=0

	# Timing
	local total_time=0

	local start_time=`date +%s`
	build_args ${compile[@]}|while read args; do
		info_start Setting $compile_counter/$total_instances: `for i in $(seq 0 $((${#compile[@]} - 1)));do echo "${compile[$i]}=$(echo $args|cut -d ' ' -f $(($i + 1)))"; done`"... "
		instance_start=`date +%s`
		bash $script_compile $args 2>&1 > /dev/null
		success=$?

		instance_stop=`date +%s`

		if [ "x$success" == "x0" ]; then
			outcome="OK"
		else
			outcome="Failed"
			compile_success=1
		fi

		compile_time=$(($instance_stop - $instance_start))
		total_time=$(perl -e "printf(\"%.2f\", $(echo "($total_time + $compile_time)"))")
		remaining=$(perl -e "printf(\"%.2f\", $(echo "(($total_instances - $compile_counter) * ($total_time / $compile_counter))"))")
		info_stop $outcome. $compile_time sec finished on $(echo -n `get_date`)\; approx. $remaining sec left \($(perl -e "printf(\"%.2f\", $(echo "($remaining / 60)"))") minutes\)

		if [ "x$compile_counter" == "x$total_instances" ]; then
			exit $compile_success
		fi

		compile_counter=$(($compile_counter + 1))
	done

	local compile_success=${PIPESTATUS[1]}
	if [ "x$compile_success" == "x0" ]; then
		local compile_outcome="Success"
	else
		local compile_outcome="Failed"
	fi
	
	local stop_time=`date +%s`
	local overall_time=$(($stop_time - start_time))

	info $compile_outcome. Compilation took $overall_time seconds \($(($overall_time / 60)) minutes\) or $(($overall_time / $total_instances)) seconds per compilation setting \($(($overall_time / $total_instances / 60)) minutes\).

	return $compile_success
}

build_expression()
{
	while [[ $# > 0 ]]
	do
		sources="$sources $1"
		shift
	done

	## Make sure we don't pattern match and eliminate nested parenthesis in the regular expression
	## Example on how to match balanced and nested parenthesis: 
	## http://stackoverflow.com/questions/14952113/how-can-i-matches-the-nested-brackets-by-regex
	perl -i -pe 's/match\(([^,]*),(?:(\(([^()]|(?2))*\))|([^()]*))\)/echo \$line | match "$1" "$2$4"'"$sources"'/g'
}

batch()
{
	local run_instances=`count_args ${run[@]}`
	local compile_instances=`count_args ${compile[@]}`
        local dummy_compile=0

        ## If there is no compilation setting, just let the running settings go once
        if [ "$compile_instances" == "0" ]
        then
                compile_instances=1
                eval ${compile[0]}=1
                dummy_compile=1
        fi

	local restrict_expr="`echo $restrict | build_expression compile run`"
	local restrict_instances="`build_args ${compile[@]} ${run[@]} | grep -n '' | while read line
	do
		eval 'if' $restrict_expr '
		then
			echo $line
		fi'
	done | tee $temp/freyja.$$.restricted | cut -f 1 -d :|tr \\\n ' '|xargs echo`"
	local total_instances="`echo $restrict_instances | wc -w`"
	#local total_instances=$(($run_instances * $compile_instances))

        ## Do not do anything if there is no instance to compile or run
        if [ "$total_instances" == "0" ]
        then
                exit 0
        fi

	## If there was an expression defined to rerun only a few experiments
	if [ "$retry_expr" != "" ]
	then
		## Rebuild the filtering expression for for compile and run settings
		retry_expr=`echo $retry_expr | build_expression compile run`

		## Make up the complete list of settings to run and filter them using the expression
		retry_numbers="`build_args ${compile[@]} ${run[@]} | grep -n ''| while read line
		do
			eval 'if' $retry_expr '
			then
				echo $line
			fi'
		done | cut -f 1 -d :|tr \\\n ' '|xargs echo`"
	fi

	if [ "$retry_only" != "1" ]
	then
		info Will run $total_instances instances
	else
		info Will run `echo $retry_numbers|wc -w` instances
	fi

	## Initialize the instance runing counter
	local instance_number=0
	
	# Initialize output file
	local start_time=`date +%s`
	local output_dir=$experiment/$output_dir_current

	mkdir -p $output_dir

	local batch_success=0
	local compile_counter=0
	local batch_time=0
	local skipped=0

	while read flags
	do
		local run_counter=1
		local run_success=0
                if [ "$dummy_compile" != "0" ]
                then
                        flags=
                fi

		while read args
		do
			## If this instance id not part of the compbination filtered with the restricted expression, then go directly to the next without even counting it
			if [ "`cat $temp/freyja.$$.restricted|cut -f 2 -d :|grep "$flags $args"`" == "" ]
			then
				continue
			fi

			## If the test above was passed, then count this instance
			local instance_number=$(($instance_number + 1))
	
			## If this instance has been cut through the retry option, then skip it (while still counting it)
			if [ "$retry_only" != "" ] && [ "`echo $retry_numbers|tr \\\t ' '|tr -s ' '|xargs echo|tr ' ' \\\n|grep ^$instance_number$`" == "" ]
			then
				run_counter=$(($run_counter + 1))
				continue
			fi
			if [ "$dummy_compile" == "0" ]
                        then
				info_start Instance $instance_number/$total_instances: `for i in $(seq 0 $((${#compile[@]} - 1)));do echo "${compile[$i]}=$(echo $flags|cut -d ' ' -f $(($i + 1))) "; done``for i in $(seq 0 $((${#run[@]} - 1)));do echo "${run[$i]}=$(echo $args|cut -d ' ' -f $(($i + 1)))"; done`"... "
                        else
				info_start Instance $instance_number/$total_instances: `for i in $(seq 0 $((${#run[@]} - 1)));do echo "${run[$i]}=$(echo $args|cut -d ' ' -f $(($i + 1)))"; done`"... "
                        fi
			local instance_start=`date +%s`
			#local args_index=`index_seq run $args`
			local instance_name="`echo $flags $args|tr ' ' _`"
			local basename=${output_base}_${instance_name}

			## Only run this experiment if there is no output for this one
			if [ -f $output_dir/${basename}_$output_success$output_extension ] && [ "`echo $retry_numbers|tr \\\t ' '|tr -s ' '|xargs echo|tr ' ' \\\n|grep ^$instance_number$`" == "" ]
			then
				local outcome="Skipped"
				local skipped=$(($skipped + 1))
			else
				## Output the experiment output header
				## Reduces tabs and spaces to a single space, turn them to commas and frame them with double quotes
				echo $output_columns | double_quotes > $output_dir/${basename}_$output_progress$output_extension
				bash $script_run $flags $args | while read line;
				do
					## Replace single quotes with double quotes, insert commas between fields
					echo $line | commas >> $output_dir/${basename}_$output_progress$output_extension
				done

				local success=${PIPESTATUS[0]}
				if [ "x$success" == "x0" ]; then
					local outcome="OK"
					mv $output_dir/${basename}_$output_progress$output_extension $output_dir/${basename}_$output_success$output_extension
				else
					local outcome="Failed"
					## Annotate output as failed
					## Create a numeric suffix in case of successive failures
					local num=`ls $output_dir/${basename}_${output_failure}*$output_extension 2> /dev/null | wc -l`
					if [ "$num" == "0" ]
					then
						num=""
					else
						num=_$num
					fi

					mv $output_dir/${basename}_${output_progress}$output_extension $output_dir/${basename}_${output_failure}$num$output_extension

					run_success=1
				fi
			fi

			local instance_stop=`date +%s`

			## Evaluate how much time is left before completion based on average time to run previous experiments, not taking into account the ones skipped
			local run_time=$(($instance_stop - $instance_start))
			total_run=$(($instance_number - $skipped))
			if [ "$total_run" == "0" ]
			then
				total_run=1
			fi
			local batch_time=$(perl -e "printf(\"%.2f\", $(echo "($batch_time + $run_time)"))")
			local remaining=$(perl -e "printf(\"%.2f\", $(echo "(($total_instances - $instance_number) * ($batch_time / $total_run))"))")
			info_stop $outcome. $run_time sec finished on $(echo -n `get_date`)\; approx. $remaining sec left \($(perl -e "printf(\"%.2f\", $(echo "($remaining / 60)"))") minutes\)

			run_counter=$(($run_counter + 1))
		done < <(build_args ${run[@]})

		if [ "x$run_success" == "x0" ]; then
			local outcome="OK"
		else
			local outcome="Failed"
			local batch_success=1
		fi

		local compile_counter=$(($compile_counter + 1))
	done < <(build_args ${compile[@]})

	if [ "x$batch_success" == "x0" ]; then
		local batch_outcome="Success"
	else
		local batch_outcome="Failed"
	fi

	## If there was no real compile setting, reset the value to nothing
	if [ "$dummy_compile" == "1" ]
        then
		eval ${compile[0]}=
	fi

	local stop_time=`date +%s`
	local overall_time=$(($stop_time - start_time))

	info $batch_outcome. Batch took $overall_time seconds \($(($overall_time / 60)) minutes\) to run, or $(($overall_time / $total_instances)) seconds per instance run \($(($overall_time / $total_instances / 60)) minutes\).

	return $batch_success
}

match()
{
	local variable="$1"
	local expression="$2"
	shift 2

	if [ "$expression" == "" ]
	then
		expression=".*"
	fi

	while [[ $# > 0 ]]
	do
		local vars="$vars "'${'"$1"'[@]} '
		shift
	done
	local index=`eval echo $vars | tr \\\t ' ' | tr -s ' ' | tr ' ' \\\n | xargs -L 1 echo | grep -n ^$variable$ | cut -f 1 -d :`

	read line
	if [ "`echo $line|cut -f $index -d ' '|sed '/'"$expression"'/!d'`" != "" ]
	then
		return 0
	else
		return 1
	fi
}

parse_options()
{
	operation=$1
	shift

	## First catch the operation and experiment names
	case "$operation" in
		"compile")
			:
		;;
		"run" | "merge")
			experiment="$1"
			shift

			if [ "$experiment" == "" ]
			then
				error You must name the experiment to be run
				usage
				exit 1
			fi
		;;
		"fuse")
			column=$1
			shift

			if [ "$column" == "" ] || [ "`echo $column | grep ^--`" != "" ]
			then
				error You must specify a column name to fuse two experiments
				usage
				exit 1
			fi

			## Default output file
			output_file=frame.csv
		;;
		"convert")
			input_file="$1"
			shift

			if [ "$input_file" == "" ] || [ ! -f "$input_file" ]
			then
				error Invalid file or file not found: \"$input_file\"
				exit 1
			fi

			## Default output file
			output_file=table.m
		;;
		"label")
			## Valid operation, but nothing to do here
			:
		;;
		*)
			error Unknown operation
			usage

			exit 1	
		;;
	esac

	## Then parse all other options
	while [[ $# > 0 ]]
	do
		case "$1" in
			"--retry")
				shift
				case "$1" in
					"--pattern" | "-p")
						shift
						retry_expr="$1"

					;;
					"--number" | "-n")
						shift
						retry_numbers="$1"
					;;
					"--all" | "-a")
						retry_expr='/bin/true' ## An expression that returns true for all experiments
					;;
					"")
						## If an empty parameter for the filtering method manages to reach here,
						## Let it go, do nothing and catch the error later
						:
					;;
					*)
						error Unknown experiment description method: \"$1\"
						usage
						exit 1
					;;
				esac

				## If no filtering option was given, give an error message and exit
				if [ "$retry_expr" == "" ] && [ "$retry_numbers" == "" ]
				then
					error You must specify a list of instances to run again
					usage
					exit 1
				fi
			;;
			"--retry-only")
				if [ "$retry_numbers" == "" ] && [ "$retry_expr" == "" ]
				then
					error Attempting to retry only an experiment list without defining it
					usage
					exit 1
				else
					retry_only=1
				fi
			;;
			"--instance")
				shift
				instance_name="`basename $1`"

				if [ -d $experiment/$instance_name ]
				then
					if [ -d $experiment/current ]
					then
						error There is already an ongoing instance of this experiment. Finish it or delete $experiment/current and try again
						exit 1
					else
						mv $experiment/`basename $1` $experiment/current	
					fi
				fi
			;;
			"--compile")
				shift
				script_compile="$1"
			;;
			"--run")
				shift
				script_run="$1"
			;;
			"--settings")
				shift
				script_settings="$1"
			;;
			"--variables")
				shift
				script_variables="$1"
			;;
			"--output")
				shift
				output_file="$1"

				if [ -f "$output_file" ]
				then
					error Output file \"$output_file\" already exist. Delete or move it and try again
					exit 1
				fi
			;;
			"--")
				return 0
			;;
			*)
				error Unknown option: $1
				usage
				exit 1
			;;
		esac

		## Get to next argument
		shift
	done
}

## Catch exit events to clean up temporary files
## http://redsymbol.net/articles/bash-exit-traps/

finish() {
	rm -rf $temp
}
trap finish EXIT 
#trap finish EXIT 

## Fill up undefined options with default values
if [ "`echo $restrict|xargs echo`" == "" ]
then
	restrict=/bin/true
fi

script_compile=./compile
script_run=./run
script_variables=./variables

## Load environment setting files
if [ -f /etc/freyja/settings ]
then
	. /etc/freyja/settings
fi
if [ -f ~/.freyja/settings ]
then
	. ~/.freyja/settings
fi
if [ "$logfile" == "" ]
then
	logfile=/dev/null
fi
if [ "$temp" == "" ]
then
	temp=/tmp
fi
temp=$temp/freyja.$$.tmp
default_temp="$temp"

experiment=""
operation=""

## Parse all options
eval parse_options `for i in "$@"; do printf "\"%s\" " "$i"; done; echo`

if [ "$script_settings" != "" ]
then
	if [ ! -f $script_settings ]
	then
		error Cannot find settings file \"$script_settings\"
		exit 1
	else
		## Load global settings
		. $script_settings

		## Check if temp has been redefined; if so, add it a unique directory name
		if [ "$temp" != "$default_temp" ]
		then
			temp=$temp/freyja.$$.tmp
		fi
	fi
fi

mkdir -p $temp
echo -n "" > $logfile

case "$operation" in
	"compile")
		load_variables
		if [ ! -f $script_compile ]
		then
			error Cannot find compile script \"$script_compile\"
			exit 1
		fi
		compile
		exit $?
	;;

	"run")
		load_variables
		if [ ! -f $script_run ]
		then
			error Cannot find run script \"$script_run\"
			exit 1
		fi

		batch
		batch_success=$?
		
		if [ "$batch_success" == "0" ]
		then
			if [ "$instance_name" = "" ]
			then
				filename=`get_date_filename`
			else
				filename=$instance_name
			fi
			mv $experiment/$output_dir_current $experiment/$filename
		else
			filename=$output_dir_current
		fi

		## Create a csv file from the experiment instance that was just run
		merge_dir $experiment/$filename/$data$ext $experiment/$filename
		## Merge all instances of this experiment into one single file
		merge_dir $experiment/$data$ext `ls -d $experiment/*`
		cp $experiment/$data$ext ./$output_file

		## Create an alias file
		build_aliases > $labels_filename

		exit $batch_success
	;;

	"merge")
		load_variables
		merge_dir $experiment/$data$ext `ls -d $experiment/*`
		cp $experiment/$data$ext ./$output_file

		exit 0
	;;

	"label")
		load_variables
		build_aliases > $labels_filename

		exit $?
	;;

	"fuse")
		## Skip all arguments until we finally find the list of files to fuse
		while [ "$1" != "--" ]
		do
			shift
		done
		shift

		## Take the header of the first file to merge
		cat $1 | head -1 | sed 's/^/"'$column'",/g' > $output_file

		## Merge several csv files into a third bigger, with an additional column
		counter=0
		while [[ $# > 0 ]]
		do
			cat $1 | tail -n +2 | sed 's/^/"'$counter'",/g' >> $output_file
			counter=$(( $counter + 1 ))
			shift
		done
	;;

	"convert")
		load_variables

		convert_csv_to_m "$input_file" "$output_file"
		## Convert a csv file to a matlab-readable cell file
		:
	;;
esac

