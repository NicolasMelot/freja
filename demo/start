#!/bin/bash

## Load global settings
. ./settings

## Load experiment variable data
. ./variables

## Load functions to resolve aliases
. ./resolver

log_start()
{
	echo -n "$@"
	echo -n "$@" >> $logfile

}

log_stop()
{
	echo "$@"
	echo "$@" >> $logfile
}

log()
{
	log_start "$@"
	log_stop ""
}

run()
{
#	log "[CMD] " "$@"
	$@
}

info_start()
{
	log_start '[INFO] '"$@"
}

info_stop()
{
	log_stop "$@"
}

info()
{
	info_start "$@"
	info_stop ""
}

error()
{
	log '[ERROR] '"$@"
}

usage()
{
	echo ./start \[compile\|run\] \<experiment\>
}

cut_head()
{
	echo \(`echo $@|cut -f 1 -d ' ' --complement`\)
}

get_date()
{
	echo `date +%D\ %R:%S`
}

get_date_filename()
{
	date|tr ' ' _|tr : -
}

build_args()
{
	# $1 is the variable containing the list of variables to be listed
	local myvars=
	local next_step=
	eval myvars=\(`echo $@`\)
	eval next_step=`cut_head ${myvars[@]}`
	local var=${myvars[0]}

	for val in `eval echo \$\{$var\[\@\]\}`
	do
		if [ "x$#" != "x1" ];
		then
			build_args ${next_step[@]}|while read line
			do
				echo $val $line
			done
		else
			echo $val
		fi
	done
}

count_args()
{
	local arg_count=1
	local myvars=
	eval myvars=\(`echo $@`\)

	for var in ${myvars[@]};
	do
		arg_count=$(($arg_count * $(echo $(eval echo \$\{$var\[\@\]\})|wc -w)))
	done
	echo $arg_count
}

merge_dir()
{
	local output_file="$1"
	shift

	info Merging all results to $output_file

	if [ -f references ]
	then
		. ./references
	fi

	## Output data to file
	echo -e $DATA_BEGIN > $output_file
	while [ "$#" != "0" ]
	do
		local input_dir=$1

		## Process this argument only if it is a directory
		if [ -d $input_dir ]
		then
			echo % From $input_dir >> $output_file
			ls $input_dir/${output_base}_*_{$output_success,$output_failure}* 2> /dev/null | sort -V | xargs cat | tr \\\t ' ' | tr -s ' ' >> $output_file
		fi
	
		shift
	done
	echo -e $DATA_END >> $output_file

	## Output column names to file
	echo -e $COLUMNS_BEGIN >> $output_file
	echo ${compile[@]}\ ${run[@]}\ $output_columns | tr \\\t ' ' | tr -s ' ' | tr ' ' \\\n | while read line; do echo -en \'$line\'\ | tr _ ' ' | tr '~' '_'; done >> $output_file
	echo -e $COLUMNS_END >> $output_file

	## Output value symbols to file
	echo -e $SYMB_BEGIN >> $output_file
	local variable="${compile[@]} ${run[@]} $output_columns"
	eval variable=\($variable\)
	local variable_size=${#variable[@]}

	seq 0 $(($variable_size - 1)) | tr ' ' \\\n | while read i
	do
		local symb=symb_${variable[$i]}
		eval symb=\('$'$symb\)
		local symb_size=${#symb[@]}

		local ref=ref_${variable[$i]}
		eval ref=\('$'$ref\)
		local ref_size=${#ref[@]}

		if (( $symb_size > 0 )) && (( $ref_size > 0 ))
		then
			echo -n "{"
			for i in ${symb[@]}
			do
				echo -n \'$i\'\  
			done
			echo -n "} "
		else
			## OK there was no symbol collected, but maybe there are symbols anyway
			## for run-generated columns
			local alias=alias_${variable[$i]}
			eval alias=\('$'$alias\)
			local alias_size=${#alias[@]}

			if (( $alias_size > 0 ))
			then
			echo -n "{"
				for i in ${alias[@]}
				do
					echo -n \'$i\'\  
				done
				echo -n "} "			
			else
				## Otherwise...
				local values=${variable[$i]}
				eval values=\('$'$values\)

				if ! is_number_seq ${values[@]}
				then
					## If it is NOT a numeric column, then generate a row with non-numeric raw values
					echo -n "{"
					for i in ${values[@]}
					do
						echo -n \'$i\'\  
					done
					echo -n "} "
				else
					## Else generate an empty row
					echo -n '{} '
				fi
			fi
		fi
	done | tr _ ' ' | tr '~' _ >> $output_file
	echo -e $SYMB_END >> $output_file

	## Output value reference to file
	echo -e $REF_BEGIN >> $output_file
	local variable="${compile[@]} ${run[@]} $output_columns"
	eval variable=\($variable\)
	local variable_size=${#variable[@]}

	seq 0 $(($variable_size - 1)) | tr ' ' \\\n | while read i
	do
		local ref=ref_${variable[$i]}
		eval ref=\('$'$ref\)
		local ref_size=${#ref[@]}

		if (( $ref_size > 0 ))
		then
			echo -n "{"
			for i in ${ref[@]}
			do
				echo -n \'$i\'\  
			done
			echo -n "} "
		else
			## Otherwise...
			local values=${variable[$i]}
			eval values=\('$'$values\)

			if ! is_number_seq ${values[@]}
			then
				## If it is NOT a numeric column, then generate a row with non-numeric raw values
				echo -n "{"
				for i in ${values[@]}
				do
					echo -n \'$i\'\  
				done
				echo -n "} "
			else
				## Else generate an empty row
				echo -n '{} '
			fi
		fi
	done >> $output_file
	echo -e $REF_END >> $output_file
}

compile()
{
	local total_instances=`count_args ${compile[@]}`

        ## Do not do anything if there is no instance to compile
        if [ "$total_instances" == "0" ]
        then
                exit 0
        fi

	info Will compile $total_instances settings

	local compile_counter=1

	# Success
	local compile_success=0

	# Timing
	local total_time=0

	local start_time=`date +%s`
	build_args ${compile[@]}|while read args; do
		info_start Setting $compile_counter/$total_instances: `for i in $(seq 0 $((${#compile[@]} - 1)));do echo "${compile[$i]}=$(echo $args|cut -d ' ' -f $(($i + 1)))"; done`"... "
		instance_start=`date +%s`
		bash ./compile $args 2>&1 > /dev/null
		success=$?

		instance_stop=`date +%s`

		if [ "x$success" == "x0" ]; then
			outcome="OK"
		else
			outcome="Failed"
			compile_success=1
		fi

		compile_time=$(($instance_stop - $instance_start))
		total_time=$(perl -e "printf(\"%.2f\", $(echo "($total_time + $compile_time)"))")
		remaining=$(perl -e "printf(\"%.2f\", $(echo "(($total_instances - $compile_counter) * ($total_time / $compile_counter))"))")
		info_stop $outcome. $compile_time sec finished on $(echo -n `get_date`)\; approx. $remaining sec left \($(perl -e "printf(\"%.2f\", $(echo "($remaining / 60)"))") minutes\)

		if [ "x$compile_counter" == "x$total_instances" ]; then
			exit $compile_success
		fi

		compile_counter=$(($compile_counter + 1))
	done

	local compile_success=${PIPESTATUS[1]}
	if [ "x$compile_success" == "x0" ]; then
		local compile_outcome="Success"
	else
		local compile_outcome="Failed"
	fi
	
	local stop_time=`date +%s`
	local overall_time=$(($stop_time - start_time))

	info $compile_outcome. Compilation took $overall_time seconds \($(($overall_time / 60)) minutes\) or $(($overall_time / $total_instances)) seconds per compilation setting \($(($overall_time / $total_instances / 60)) minutes\).

	return $compile_success
}

batch()
{
	local run_instances=`count_args ${run[@]}`
	local compile_instances=`count_args ${compile[@]}`
	local total_instances=$(($run_instances * $compile_instances))

        ## Do not do anything if there is no instance to compile or run
        if [ "$total_instances" == "0" ]
        then
                exit 0
        fi

	info Will run $total_instances instances

	# Initialize output file
	local start_time=`date +%s`
	local output_dir=$experiment/$output_dir_current

	mkdir -p $output_dir

	local batch_success=0
	local compile_counter=0
	local batch_time=0
	local skipped=0

	while read flags
	do
		local run_counter=1
		local run_success=0
		local flags_index=`index_seq compile $flags`

		while read args
		do
			local instance_number=$((compile_counter * $run_instances + $run_counter))
			info_start Instance $instance_number/$total_instances: `for i in $(seq 0 $((${#compile[@]} - 1)));do echo "${compile[$i]}=$(echo $flags|cut -d ' ' -f $(($i + 1))) "; done``for i in $(seq 0 $((${#run[@]} - 1)));do echo "${run[$i]}=$(echo $args|cut -d ' ' -f $(($i + 1)))"; done`"... "
			local instance_start=`date +%s`
			local args_index=`index_seq run $args`
			local basename=${output_base}_${instance_number}

			## Only run this experiment if there is no output for this one
			if [ -f $output_dir/${basename}_$output_success ]
			then
				local outcome="Skipped"
				local skipped=$(($skipped + 1))
			else
				touch $output_dir/${basename}_$output_progress
				bash ./run $flags $args | while read line;
				do
					local content=`echo $line | tr \\\t ' ' | tr -s ' ' | xargs echo`
					if [ "x`echo $content|grep ^%`" == "x" ]; then
						echo $flags_index $args_index $content >> $output_dir/${basename}_$output_progress
					else
						echo $line >> $output_dir/${basename}_$output_progress
					fi
				done

				local success=${PIPESTATUS[0]}
				if [ "x$success" == "x0" ]; then
					local outcome="OK"
					mv $output_dir/${basename}_$output_progress $output_dir/${basename}_$output_success
				else
					local outcome="Failed"
					## Annotate output as failed
					## Create a numeric suffix in case of successive failures
					local num=`ls $output_dir/${basename}_${output_failure}* 2> /dev/null | wc -l`
					if [ "$num" == "0" ]
					then
						num=""
					else
						num=_$num
					fi

					echo % $failed_begin > $output_dir/${basename}_${output_failure}$num
					cat $output_dir/${basename}_${output_progress} | while read line_fail; do
						echo % $line_fail >> $output_dir/${basename}_${output_failure}$num
					done
					echo % $failed_end >> $output_dir/${basename}_${output_failure}$num
					rm $output_dir/${basename}_$output_progress

					run_success=1
				fi
			fi

			local instance_stop=`date +%s`

			## Evaluate how much time is left before completion based on average time to run previous experiments, not taking into account the ones skipped
			local run_time=$(($instance_stop - $instance_start))
			total_run=$(($instance_number - $skipped))
			if [ "$total_run" == "0" ]
			then
				total_run=1
			fi
			local batch_time=$(perl -e "printf(\"%.2f\", $(echo "($batch_time + $run_time)"))")
			local remaining=$(perl -e "printf(\"%.2f\", $(echo "(($total_instances - $instance_number) * ($batch_time / $total_run))"))")
			info_stop $outcome. $run_time sec finished on $(echo -n `get_date`)\; approx. $remaining sec left \($(perl -e "printf(\"%.2f\", $(echo "($remaining / 60)"))") minutes\)

			run_counter=$(($run_counter + 1))
		done < <(build_args ${run[@]})

		if [ "x$run_success" == "x0" ]; then
			local outcome="OK"
		else
			local outcome="Failed"
			local batch_success=1
		fi

		local compile_counter=$(($compile_counter + 1))
	done < <(build_args ${compile[@]})

	if [ "x$batch_success" == "x0" ]; then
		local batch_outcome="Success"
	else
		local batch_outcome="Failed"
	fi

	local stop_time=`date +%s`
	local overall_time=$(($stop_time - start_time))

	info $batch_outcome. Batch took $overall_time seconds \($(($overall_time / 60)) minutes\) to run, or $(($overall_time / $total_instances)) seconds per instance run \($(($overall_time / $total_instances / 60)) minutes\).

	return $batch_success
}

operation=$1
experiment=$2

echo -n "" > $logfile

case "x$operation" in
	"xcompile")
		compile
		exit $?
	;;

	"xrun")
		if [ "x$experiment" == "x" ];
		then
			error You must name the experiment to be run
			usage
			exit 1
		else
			batch
			batch_success=$?
			
			if [ "$batch_success" == "0" ]
			then
				filename=`get_date_filename`
				mv $experiment/$output_dir_current $experiment/$filename
			else
				filename=$output_dir_current
			fi
			merge_dir $experiment/$filename/$data$ext $experiment/$filename
			merge_dir $experiment/$data$ext `ls -d $experiment/*`
			cp $experiment/$data$ext .

			exit $batch_success
		fi
	;;

	"xmerge")
		if [ "x$experiment" == "x" ];
		then
			error You must name the experiment to be merged
			usage
			exit 1
		else
			merge_dir $experiment/$data$ext `ls -d $experiment/*`
			cp $experiment/$data$ext .

			exit 0
		fi
	;;		

	*)
		error Unknown operation
		usage

		exit 1
	;;
esac

