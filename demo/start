#!/bin/bash -f

. ./settings
. ./variables

log_start()
{
	echo -n "$@"
	echo -n "$@" >> $logfile

}

log_stop()
{
	echo "$@"
	echo "$@" >> $logfile
}

log()
{
	log_start "$@"
	log_stop ""
}

run()
{
#	log "[CMD] " "$@"
	$@
}

info_start()
{
	log_start '[INFO] '"$@"
}

info_stop()
{
	log_stop "$@"
}

info()
{
	info_start "$@"
	info_stop ""
}

error()
{
	log '[ERROR] '"$@"
}

usage()
{
	echo ./start \[compile\|run\] \<experiment\>
}

cut_head()
{
	echo \(`echo $@|cut -f 1 -d ' ' --complement`\)
}

get_date()
{
	echo `date +%D\ %R:%S`
}

get_date_filename()
{
	date|tr ' ' _|tr : -
}

build_args()
{
	# $1 is the variable containing the list of variables to be listed
	eval myvars=\(`echo $@`\)
	eval next_step=`cut_head ${myvars[@]}`
	var=${myvars[0]}

	for val in `eval echo \$\{$var\[\@\]\}`
	do
		if [ "x$#" != "x1" ];
		then
			build_args ${next_step[@]}|while read line
			do
				echo $val $line
			done
		else
			echo $val
		fi
	done
}

count_args()
{
	count=1
	eval myvars=\(`echo $@`\)

	for var in ${myvars[@]};
	do
		count=$(($count * $(echo $(eval echo \$\{$var\[\@\]\})|wc -w)))
	done
	echo $count
}

merge_dir()
{
	output_file="$1"
	shift

	info Merging all results to $output_file

	echo -e $DATA_BEGIN > $output_file
	while [ "$#" != "0" ]
	do
		input_dir=$1

		## Process this argument only if it is a directory
		if [ -d $input_dir ]
		then
			ls $input_dir/${output_base}_*_{$output_success,$output_failure}* 2> /dev/null | sort -V | xargs cat | while read line;
			do
				# Add content to output file
				content=`echo $line | tr \\\t ' ' | tr -s ' ' | xargs echo`
				if [ "x`echo $content | grep ^%`" == "x" ]; then
					echo $flags $args $content >> $output_file
				else
					if [ "x`echo $line | tr \\\t ' ' | tr -d ' ' | grep ^%$columns_list_name=`" == "x" ]; then
						echo $line >> $output_file
					else
						echo $line | cut -f 2 -d = > $columns_file
					fi
				fi
			done
		fi
	
		shift
	done
	echo -e $DATA_END >> $output_file

	echo -e $COLUMNS_BEGIN >> $output_file
	fields="`cat $columns_file | head -1`"
	rm $columns_file
	echo ${compile[@]}\ ${run[@]}\ $fields|tr \\\t ' '|tr -s ' '|tr ' ' \\\n|while read line; do echo -en \'$line\'\ ; done >> $output_file
	echo -e $COLUMNS_END >> $output_file
}

compile()
{
	total_instances=`count_args ${compile[@]}`
	info Will compile $total_instances settings

	compile_counter=1

	# Success
	compile_success=0

	# Timing
	total_time=0

	start_time=`date +%s`
	build_args ${compile[@]}|while read args; do
		info_start Setting $compile_counter/$total_instances: `for i in $(seq 0 $((${#compile[@]} - 1)));do echo "${compile[$i]}=$(echo $args|cut -d ' ' -f $(($i + 1)))"; done`"... "
		instance_start=`date +%s`
		bash ./compile $args 2>&1 > /dev/null
		success=$?

		instance_stop=`date +%s`

		if [ "x$success" == "x0" ]; then
			outcome="OK"
		else
			outcome="Failed"
			compile_success=1
		fi

		compile_time=$(($instance_stop - $instance_start))
		total_time=$(perl -e "printf(\"%.2f\", $(echo "($total_time + $compile_time)"))")
		remaining=$(perl -e "printf(\"%.2f\", $(echo "(($total_instances - $compile_counter) * ($total_time / $compile_counter))"))")
		info_stop $outcome. $compile_time sec finished on $(echo -n `get_date`)\; approx. $remaining sec left \($(perl -e "printf(\"%.2f\", $(echo "($remaining / 60)"))") minutes\)

		if [ "x$compile_counter" == "x$total_instances" ]; then
			exit $compile_success
		fi

		compile_counter=$(($compile_counter + 1))
	done

	compile_success=${PIPESTATUS[1]}
	if [ "x$compile_success" == "x0" ]; then
		compile_outcome="Success"
	else
		compile_outcome="Failed"
	fi
	
	stop_time=`date +%s`
	overall_time=$(($stop_time - start_time))

	info $compile_outcome. Compilation took $overall_time seconds \($(($overall_time / 60)) minutes\) or $(($overall_time / $total_instances)) seconds per compilation setting \($(($overall_time / $total_instances / 60)) minutes\).

	return $compile_success
}

batch()
{
	run_instances=`count_args ${run[@]}`
	compile_instances=`count_args ${compile[@]}`
	total_instances=$(($run_instances * $compile_instances))

	info Will run $total_instances instances

	# Initialize output file
	start_time=`date +%s`
	output_dir=$experiment/$output_dir_current

	mkdir -p $output_dir

	batch_success=0
	compile_counter=0
	batch_time=0
	skipped=0

	while read flags
	do
		run_counter=1
		run_success=0

		while read args
		do
			instance_number=$((compile_counter * $run_instances + $run_counter))
			info_start Instance $instance_number/$total_instances: `for i in $(seq 0 $((${#compile[@]} - 1)));do echo "${compile[$i]}=$(echo $flags|cut -d ' ' -f $(($i + 1))) "; done``for i in $(seq 0 $((${#run[@]} - 1)));do echo "${run[$i]}=$(echo $args|cut -d ' ' -f $(($i + 1)))"; done`"... "
			instance_start=`date +%s`

			#old_size=$(cat $filename|wc -l)
			basename=${output_base}_${instance_number}

			## Only run this experiment if there is no output for this one
			if [ -f $output_dir/${basename}_$output_success ]
			then
				outcome="Skipped"
				skipped=$(($skipped + 1))
			else
				## This one is already done, skip
				bash ./run $flags $args | while read line;
				do
					content=`echo $line | tr \\\t ' ' | tr -s ' ' | xargs echo`
					if [ "x`echo $content|grep ^%`" == "x" ]; then
						echo $flags $args $content >> $output_dir/${basename}_$output_progress
					else
						echo $line >> $output_dir/${basename}_$output_progress
					fi
				done

				success=${PIPESTATUS[0]}
				if [ "x$success" == "x0" ]; then
					outcome="OK"
					mv $output_dir/${basename}_$output_progress $output_dir/${basename}_$output_success
				else
					outcome="Failed"
					## Annotate output as failed
					## Create a numeric suffix in case of successive failures
					num=`ls $output_dir/${basename}_${output_failure}* 2> /dev/null | wc -l`
					if [ "$num" == "0" ]
					then
						num=""
					else
						num=_$num
					fi

					echo % $failed_begin > $output_dir/${basename}_${output_failure}$num
					cat $output_dir/${basename}_${output_progress} | while read line_fail; do
						echo % $line_fail >> $output_dir/${basename}_${output_failure}$num
					done
					echo % $failed_end >> $output_dir/${basename}_${output_failure}$num
					rm $output_dir/${basename}_$output_progress

					run_success=1
				fi
			fi

			instance_stop=`date +%s`

			## Evaluate how much time is left before completion based on average time to run previous experiments, not taking into account the ones skipped
			run_time=$(($instance_stop - $instance_start))
			total_run=$(($instance_number - $skipped))
			if [ "$total_run" == "0" ]
			then
				total_run=1
			fi
			batch_time=$(perl -e "printf(\"%.2f\", $(echo "($batch_time + $run_time)"))")
			remaining=$(perl -e "printf(\"%.2f\", $(echo "(($total_instances - $instance_number) * ($batch_time / $total_run))"))")
			info_stop $outcome. $run_time sec finished on $(echo -n `get_date`)\; approx. $remaining sec left \($(perl -e "printf(\"%.2f\", $(echo "($remaining / 60)"))") minutes\)

			run_counter=$(($run_counter + 1))
		done < <(build_args ${run[@]})

		if [ "x$run_success" == "x0" ]; then
			outcome="OK"
		else
			outcome="Failed"
			batch_success=1
		fi

		compile_counter=$(($compile_counter + 1))
	done < <(build_args ${compile[@]})

	if [ "x$batch_success" == "x0" ]; then
		batch_outcome="Success"
	else
		batch_outcome="Failed"
	fi

	merge_dir $output_dir/$data$ext $output_dir

	stop_time=`date +%s`
	overall_time=$(($stop_time - start_time))

	info $batch_outcome. Batch took $overall_time seconds \($(($overall_time / 60)) minutes\) to run, or $(($overall_time / $total_instances)) seconds per instance run \($(($overall_time / $total_instances / 60)) minutes\).

	return $batch_success
}

operation=$1
experiment=$2

echo -n "" > $logfile

case "x$operation" in
	"xcompile")
		compile
		exit $?
	;;

	"xrun")
		if [ "x$experiment" == "x" ];
		then
			error You must name the experiment to be run
			usage
			exit 1
		else
			batch
			batch_success=$?
			
			if [ "$batch_success" == "0" ]
			then
				filename=`get_date_filename`
				mv $experiment/$output_dir_current $experiment/$filename
			else
				filename=$output_dir_current
			fi
			cp $experiment/$filename/$data$ext .

			exit $batch_success
		fi
	;;

	"xmerge")
		if [ "x$experiment" == "x" ];
		then
			error You must name the experiment to be merged
			usage
			exit 1
		else
			merge_dir $experiment/$data$ext `ls -d $experiment/*`
			cp $experiment/$data$ext .

			exit 0
		fi
	;;		

	*)
		error Unknown operation
		usage

		exit 1
	;;
esac

