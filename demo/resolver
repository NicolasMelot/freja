#!/bin/bash

trap exiting SIGINT
cleanup()
{
	rm /tmp/ref.$$.tmp
	exit 1
}

## Returns true if $1 is an integer or a decimal
is_number()
{
	printf %f\\n $1 > /dev/null 2>&1
}

## Returns true if all space-separated elements of $@ (regardless of double quotes") are an integers or decimal value
is_number_seq()
{
	local first="$1"
	shift

	if (( $# > 0 ))
	then

		is_number "$first"
		local head=$?
		is_number_seq $@
		local tail=$?

		return $(($head || $tail))
	else
		is_number "$first"
	fi
}

## Returns the numeric index of a string in a non-numeric sequence stored in a variable in the variables files
## Save the symbolic values and alias in the file "references" to prevent the use of the same index for a different
## variable value, accross different batch runs
## If the string is a numeric value coming from a numeric sequence, then return the same numeric string
index()
{
	# $1 is variable name
	# $2 is variable value we want to get index of
	local variable=$1
	local value=$2
	local i=0

	## Load the content of variable files
	. ./variables
	local content=
	eval content=\('$'$variable\)
	local size_content=${#content[@]}

	## Get the index of the value given
	for i in `seq 0 $(( $size_content - 1 ))`
	do
		if [ "$value" == "${content[$i]}" ]
		then
			value_index=$i
		fi
	done

	## Load variable references, if any
	if [ -f ./references ]
	then
		. ./references
	fi

	local symb_var=symb_$variable
	eval symb_var=\('$'$symb_var\)

	## Check if there is an alias for this variable
	local alias_var=alias_$variable
	eval alias_var=\('$'$alias_var\)
	
	local ref_var=ref_$variable
	eval ref_var=\('$'$ref_var\)

	## If the variable is not a numeric sequence or if an alias was given	
	if ! is_number_seq ${content[@]} || (( ${#alias_var[@]} != 0 )) || (( ${#content[@]} == 0 )) || (( ${#ref_var[@]} != 0 ))
	then
		ref_var=ref_$variable
		eval ref_var=\('$'$ref_var\)

		local size=${#ref_var[@]}
		final_i=0
		for i in `seq 0 $(($size - 1))`
		do
			#echo [DEBUG][$0:$LINENO] Is my value \($value\) the same as the $i'th' element of alias_var=\"${ref_var[@]}\" \(${ref_var[$i]}\) >&2
			if [ "$value" == "${ref_var[$i]}" ]
			then
				## return the index value requested
				echo $i

				## Update this symbol with the alias given
				if [ "${alias_var[$value_index]}" == "" ]
				then
					symb_var[$i]=$value
				else
					symb_var[$i]=${alias_var[$value_index]}
				fi
				if [ -f references ]
				then
					cat references | grep -Ev '^symb_'$variable= > /tmp/ref.$$.tmp
					cat /tmp/ref.$$.tmp > references
					rm /tmp/ref.$$.tmp
				fi
				echo -n symb_$variable'=" ' >> references
				for j in `seq 0 $((${#ref_var[@]} - 1))`
				do
					if [ "${symb_var[$j]}" == "" ]
					then
						echo -n "'' " >> references
					else
						echo -n ${symb_var[$j]}" " >> references
					fi
				done
				echo '"' >> references

				## Return from the function
				return 0
			fi
			final_i=$(($i + 1))
		done
		
		i=$final_i

		## If no reference value could be found, then
		## just issue a new index
		echo $i

		## Add this new value to the reference list
		if [ "${symb_var[$i]}" == "" ]
		then
			symb_var[$i]=$value
		fi
		ref_var[$i]=$value

		if [ -f references ]
		then
			cat references | grep -Ev '^(ref|symb)_'$variable= > /tmp/ref.$$.tmp
			cat /tmp/ref.$$.tmp > references
			rm /tmp/ref.$$.tmp
		fi
		
		echo -n symb_$variable'=" ' >> references
		for j in `seq 0 $((${#ref_var[@]} - 1))`
		do
			if [ "${symb_var[$j]}" == "" ]
			then
				echo -n "'' " >> references
			else
				echo -n ${symb_var[$j]}" " >> references
			fi
		done
		echo '"' >> references

		echo -n ref_$variable'=" ' >> references
		for j in `seq 0 $i`
		do
			if [ "${ref_var[$j]}" == "" ]
			then
				echo -n $value" " >> references
			else
				echo -n ${ref_var[$j]}" " >> references
			fi
		done
		echo '"' >> references
	else
		echo $value

		if [ -f references ]
		then
			cat references | grep -Ev '^(ref|symb)_'$variable= > /tmp/ref.$$.tmp
			cat /tmp/ref.$$.tmp > references
			rm /tmp/ref.$$.tmp
		fi
	fi
}

## returns the string value corresponding to the index in a variable from the variables file
value()
{
	local variable=$1
	local index=$2

	## Load the content of variables file
	. ./variables

	local var=
	eval var=\('$'$variable\)
	echo ${var[$index]}
}

## Transforms each value in the input sequence into its index equivalent according to variable sequence given in category
index_seq()
{
	local category=$1

	## Get the rest of arguments to parse
	shift
	local args="$@"
	eval args=\($args\)

	## Load the content of variables file
	. ./variables
	size=$#
	eval category='(${'$category'[@]})'

	for i in `seq 0 $(($size - 1))`
	do
		local variable=${category[$i]}
		echo -n `index $variable ${args[$i]}`\ 
	done
	echo
}
