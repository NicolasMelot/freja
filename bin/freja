#!/bin/bash

# Copyright 2015 Nicolas Melot
#
# This file is part of Freja.
#
# Freja is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Freja is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Freja. If not, see <http://www.gnu.org/licenses/>.
#


log_start()
{
	echo -n "$@"

	if [ "$logfile" != "" ]
	then
		echo -n "$@" >> $logfile
	fi
}

log_stop()
{
	echo "$@"

	if [ "$logfile" != "" ]
	then
		echo "$@" >> $logfile
	fi
}

log()
{
	log_start "$@"
	log_stop ""
}

silentlog()
{
	log_start "$@" > /dev/null 2>&1
	log_stop "" > /dev/null 2>&1
}

run()
{
	$@
}

info_start()
{
	log_start '[INFO] '"$@"
}

info_stop()
{
	log_stop "$@"
}

info()
{
	info_start "$@"
	info_stop ""
}

error()
{
	log '[ERROR] '"$@"
}

warning()
{
	log '[WARN ] '"$@"
}

## Load the variable file, if any, or display an error message and exits
load_variables()
{
	if [ ! -f $script_variables ]
	then
		error Cannot find variables file \"$script_variables\"
		exit 1
	else
		## Load experiment variable data
		. $script_variables
	fi
}

## Returns true if $1 is an integer or a decimal
is_number()
{
	printf %f\\n $1 > /dev/null 2>&1
}

## Returns true if all space-separated elements of $@ (regardless of double quotes) are an integers or decimal value
is_number_seq()
{
	res=0
	local i=0
	for i in $@
	do
		if ! is_number $i
		then
			res=1
		fi
	done

	return $res
}

usage()
{
	echo 
	echo
	echo 'freja [ compile | [ run | merge | label ] <experiment> | fuse <column> <list of csv filenames> |'
	echo '		convert <csv filename> ] [--instance <instance name>]'
	echo '	[--retry [[--number | -n <numbers>] | [--pattern | -p <expression>] | --all] [--retry-only]]'
	echo '	[--variables <variable filename> ] [--compile <compilation script> ] [--run <run script> ] [--log <log file> ]'
	echo '  [--output <output file> ]'
	echo
	echo "	<experiment>	Space-free, filename-valid string that name a category of the experiment batch being run."
	echo "				The results of all batches of the same category are merge together without any"
	echo "				data to differentiate them. Several experiments of the same category may be run"
	echo "				to generating more data."
	echo "	<instance name>	Space-free, filename-valid string to name a duplication of an experiment within an experiment"
	echo "				category. Current day, and time as obtain by \"'date|tr ' ' _|tr : -\" by default."
	echo "				If no name is given, continues the experiment duplicate previously interrupted, or"
	echo "				begin a new one with a default name. Depending on options, all running instances of an"
	echo "				experiment duplicate are not run again unless their previous run failed."
	echo '	--retry		Run again an experiment duplicate (or any previous duplicate previously  interrupted) but filters'
	echo '				the running instances after some filter given by one of the options --numbers or --pattern'
	echo '	--number	With --retry, expects <numbers>, a list of running instance numbers as given by any batch output'
	echo '				which will be run again even if they alread succeed in a previous run'
	echo "	<number>	Space separated instance numbers to run again as given by a previous run. If more than"
	echo "				one number, they should be protected with simple or double quotes \(\"1 2 3 4\"\)."
	echo '	--pattern	With --retry and an <expression>, run again all running instances that satisfy the expression'
	echo "	<expression>	Bash-format boolean expression that is tested against all variable combinations. If"
	echo "				The expression returns true (the command returns 0), then this experiment instance is"
	echo "				run again. Otherwise (the command returns an non-zero value) this instance is not run."
	echo "				you can use the function match(<variable>, <regex>) that return true if the sed regular"
	echo "				expression <regex> matches the value of the variable <variable> and false otherwise."
	echo '	--retry-only		Only re-run the running instances requested by --numbers or --pattern options. Otherwise'
	echo '				run also all running instances that previously failed or were never run.'
	echo 
	echo "	For more information: https://www.ida.liu.se/~nicme26"
}

cut_head()
{
	echo \(`echo $@|cut -f 1 -d ' ' --complement`\)
}

get_date()
{
	echo `date +%D\ %R:%S`
}

get_date_filename()
{
	date | tr ' ' _ | tr : -
}

build_values()
{
	local myvars=
	local next_step=
	eval myvars=\(`echo $@`\)
	eval next_step=`cut_head ${myvars[@]}`
	local var=${myvars[0]}

	if [ "$var" != "" ]
	then
		var=`eval echo \$\{$var\[\@\]\}`
		for val in ${var[@]}
		do
			## If var is not a numeric variable, then surround its value with double quotes
			if ! is_number_seq ${var[@]}
			then
				val=\"$val\"
			fi

			if [ "$#" != "1" ];
			then
				build_values ${next_step[@]}|while read line
				do
					echo $val $line
				done
			else
				echo $val
			fi
		done
	fi
}

build_args()
{
	build_values $@ | tr -d '"'
}

count_args()
{
	if [ "$1" == "" ]
	then
		local arg_count=0
	else
		local arg_count=1
	fi
	local myvars=
	eval myvars=\(`echo $@`\)

	for var in ${myvars[@]};
	do
		arg_count=$(($arg_count * $(echo $(eval echo \$\{$var\[\@\]\})|wc -w)))
	done
	echo $arg_count
}

double_quotes()
{
	tr \\\t ' '|tr -s ' '|xargs echo|sed 's/ /","/g'|sed 's/^/"/g'|sed 's/$/"/g'
}

commas()
{
	sed 's/"/"\\\\\"/g' | while read i; do :(){ for i in "$@"; do echo -n $i,; done | sed 's/,$/\n/g'; }; eval : $i; done
}

build_aliases()
{
	## Take as a base the labelling functions snippet
	cat $labels_snippet_filename

	## Synthetize labels for column combinations. Process described in more details in the next loop block
	echo -en "combination = list(\n\t"
	for i in $combination
	do
		if [ "`eval echo '$'comb_$i`" != "" ]
		then
			## Output the column name ready to receive the vector
			echo -en "$i = c("

			## Iterate through all pairs (key,label)
			for j in $(eval echo '$'comb_$i)
			do
				echo -n '\"'$j'\"',\ 
			done | rev | cut -f 1 -d ',' --complement | rev | xargs echo -n

			echo -n "), "
		fi 
	done | rev | cut -f 1 -d ',' --complement | rev
	echo ")"
	echo

	## Begin with a list of columns
	echo "labels = list("
	### Then find aliases for all variables
	for i in ${compile[@]} ${run[@]} $output_columns $combination
	do
		## Only output aliases if this variable has some declared
		if [ "`eval echo '$'labels_$i`" != "" ]
		then
			## Output the column name ready to receive the vector
			echo -en "\t$i = c("

			## Iterate through all pairs (key,label)
			eval echo '$'labels_$i | tr ";" \\\n | xargs -L 1 echo | grep -v ^$ | while read j
			do
				instance="`echo $j | cut -f 1 -d : | xargs echo`"
				label="`echo $j | cut -f 1 -d : --complement | xargs echo`"
				echo -n \\\"$instance\\\" = \\\"$label\\\"', '
			done | rev | cut -f 1 -d ',' --complement | rev | xargs echo -n

			echo "),"
		fi
	done

	## Now add aliases for column names, if any
	if [ "`eval echo '$'labels_columns`" != "" ]
	then
		## Output the column name ready to receive the vector
		echo -en "\tcolumns = c("

		## Iterate through all pairs (key,label)
		eval echo '$'labels_columns | tr ";" \\\n | xargs -L 1 echo | grep -v ^$ | while read j
		do
			instance="`echo $j | cut -f 1 -d : | xargs echo`"
			label="`echo $j | cut -f 1 -d : --complement | xargs echo`"
			echo -n \\\"$instance\\\" = \\\"$label\\\"', '
		done | rev | cut -f 1 -d ',' --complement | rev | xargs echo -n
		echo ")"
	else
		## Output the column name ready to receive the vector
		echo -en "\tcolumns = c("

		## Iterate through all pairs (key,label)
		eval echo ${compile[@]} ${run[@]} '$'output_columns | tr \\\t ' ' | tr -s ' ' | tr ' ' \\\n | xargs -L 1 echo | grep -v ^$ | while read j
		do
			instance="$j"
			label="`echo $j | tr '_' ' ' | xargs echo`"
			echo -n \\\"$instance\\\" = \\\"$label\\\"', '
		done | rev | cut -f 1 -d ',' --complement | rev | xargs echo -n
		echo ")"
	fi
	## Close the list
	echo ")"
	echo

	## Add color settings
	echo -en "colors = list(\n\t"
	for i in ${compile[@]} ${run[@]} $output_columns $combination
	do
		if [ "`eval echo '$'colors_$i`" != "" ]
		then
			## Output the column name ready to receive the vector
			echo -en "$i = c("

			## Iterate through all pairs (key,label)
			eval echo '$'colors_$i | tr ";" \\\n | xargs -L 1 echo | grep -v ^$ | while read j
			do
				instance="`echo $j | cut -f 1 -d : | xargs echo`"
				color="`echo $j | cut -f 1 -d : --complement | xargs echo`"
				echo -n \\\"$instance\\\" = \\\"$color\\\"', '
			done | rev | cut -f 1 -d ',' --complement | rev | xargs echo -n

			echo -n "), "
		fi
	done | rev | cut -f 1 -d ',' --complement | rev
	echo ")"
	echo
}

convert_csv_to_m()
{
	## Return the index of value $1 for variable $2 at index $3
	find_index()
	{
		local value=$1
		local variable=$2
		local index=$3
		shift 3

		## We are in another process context; we need to reload the variable file
		load_variables

		## Keeps track if the value was found
		local found=0
		if [ "$@" != "" ]
		then
			local counter=0
			while read j
			do
				local instance="`echo $j | cut -f 1 -d : | xargs -0 echo`"
				if [ "$instance" == "$value" ]
				then
					found=1
					break
				else
					counter=$(( $counter + 1 ))
				fi
			done < <(echo $@ | tr ";" \\\n | xargs -0 -L 1 echo | grep -v ^$)
			#done < <(eval echo '$'labels_$variable | tr ";" \\\n | xargs -0 -L 1 echo | grep -v ^$)
		else
			local myindex="`echo ${compile[@]} ${run[@]} $output_columns | tr ' ' \\\n | grep -n '^'$variable'$' | cut -f 1 -d :`"
			local counter=0
			while read j
			do
				if [ "$j" == "$value" ]
				then
					break
				else
					counter=$(( $counter + 1 ))
				fi
			done < <(cat $tempfile | cut -f $myindex -d ' ' | sort -V | uniq)
		fi

		if [ "$found" == "0" ]
		then
			## !!! Yes, eliminate all simple quote and their escape that can add up 3 times
			eval eval echo Could not 'find' a label 'for' value \"$value\" in labels for variable \"$variable\" >&2
			echo $counter -1
		else
			echo $counter
		fi
	}

	local compile_instances=`count_args ${compile[@]}`
        local dummy_compile=0

        ## If there is no compilation setting, just let the running settings go once
        if [ "$compile_instances" == "0" ]
        then
                compile_instances=1
                eval ${compile[0]}=1
                dummy_compile=1
		all_columns="${run[@]} $output_columns"
	else
		all_columns="${compile[@]} ${run[@]} $output_columns"
        fi
	
	local input="$1"
	local output="$2"

	## Prepare the environment variable to export to sed's shell environment
	export -f find_index
	export -f load_variables
	export script_variables
	export input
	export tempfile=$temp/convert.$$.tmp

	## Extract a function name from the output filename, for the table to be generated
	local name="`basename $output .m`"
	echo -e $DATA_BEGIN | sed s/$table_name/$name/g > $output

	## Cut the header to create an initial, unfiltered table
	cat $input | tail -n +2 | tr -d '"' | tr ',' ' ' | sed "s/'/\\\'/g" > $temp/convert.$$.tmp
	local counter=1
	## For each variable, see if there is a label defined. If so, change the value to an index using sed
	for i in $all_columns
	do
		## Convert every column for which there is an alias or if it is not a sequence of numbers
		if [ "`eval echo '$'labels_$i`" != "" ] || ! is_number_seq `cat $temp/convert.$$.tmp | cut -f $counter -d ' '`
		then
			## make sure there is a final semicolon, then delete it
			if [ "`eval echo '$'labels_$i`" != "" ]
			then
				eval export labels_$i'="`'echo '$'labels_$i '| tr ";" \\\n | xargs -0 -L 1 echo | grep -v ^$ | tr \\\n ";"`"'
			fi

			for symbol in `cat $temp/convert.$$.tmp | cut -f $counter -d ' ' | sort | uniq`
			do
				labels="$(eval echo "$(echo '$'labels_$i)")"
				index="`find_index $symbol $i $counter "$labels"`"
				if [ "`echo $index | cut -f 2 -d ' '`" == "-1" ]
				then
					index=`echo $index | cut -f 1 -d ' '`
					eval export labels_$i'="$'labels_$i' '$(echo $symbol | tr -d \' | tr -d '\\')': '$symbol'"\;'
				else
					index=`echo $index | cut -f 1 -d ' '`
				fi

				## If this symbol has a single quote, escape it twice so it matches the table, and sed doesn't mess with the single quote
				symbol="`echo $symbol | sed "s/'/\\\\\'/g" `"
				cat $temp/convert.$$.tmp | sed 's/\(\([^ ]\+ \)\{'$(( $counter - 1 ))'\}\)\('$symbol'\)\( [^$]*\|$\)$/\1'$index'\4/g' > $temp/convert.$$.filtered.tmp
				cat $temp/convert.$$.filtered.tmp | tr -s ' ' > $temp/convert.$$.tmp
			done

			## Keep thisl ine for future reference: sed calls a program with matches as argument and replace the text with whatever this command returns (/e option)
			#cat $temp/convert.$$.tmp | sed 's/\(\([^ ]\+ \)\{'$(( $counter - 1 ))'\}\)\([^ ]\+\)\([^$]*\)$/echo -n "\1"; bash -c "find_index \3 '$i' '$counter'"; echo \4/e' > $temp/convert.$$.filtered.tmp
		fi
		
		counter=$(( $counter + 1 ))
	done
	cat $temp/convert.$$.tmp >> $output
	echo -e $DATA_END >> $output

	echo -e $COLUMNS_BEGIN >> $output
	for i in $all_columns
	do
		echo -n "'"$i"' " | tr '_' ' ' >> $output
	done		
	echo -e $COLUMNS_END >> $output

	echo -e $REF_BEGIN >> $output
	for i in $all_columns
	do
		if [ "`eval echo '$'labels_$i`" != "" ]
		then
			echo -n '{' >> $output
			eval echo '$'labels_$i | tr ";" \\\n | xargs -L 1 echo | grep -v ^$ | while read j
			do
				#local instance="`echo $j | cut -f 1 -d : | sed "s/'/"'"'"'"'"'"/g" | xargs echo | sed "s/'/''/g"`"
				local instance="`echo $j | cut -f 1 -d : | sed "s/'//g" | xargs echo | sed "s/'/''/g"`"
				echo -n "'"$instance"' " >> $output
			done
			echo -n '} ' >> $output
		else
			echo -n "{} " >> $output
		fi
	done
	echo -e $REF_END >> $output

	echo -e $SYMB_BEGIN >> $output
	for i in $all_columns
	do
		if [ "`eval echo '$'labels_$i`" != "" ]
		then
			echo -n '{' >> $output
			eval echo '$'labels_$i | tr ";" \\\n | xargs -L 1 echo | grep -v ^$ | while read j
			do
				local label="`echo $j | cut -f 1 -d : --complement | sed "s/'/"'"'"'"'"'"/g" | xargs echo | sed "s/'/''/g"`"
				echo -n "'"$label"' " >> $output
			done
			echo -n '} ' >> $output
		else
			echo -n "{} " >> $output
		fi
	done
	echo -e $SYMB_END >> $output

	
}

merge_dir()
{
	local output_file="$1"
	shift

	local compile_instances=`count_args ${compile[@]}`
        local dummy_compile=0

        ## If there is no compilation setting, just let the running settings go once
        if [ "$compile_instances" == "0" ]
        then
                compile_instances=1
		compile="nothing_$$"
                eval ${compile[0]}=1
                dummy_compile=1
        fi

	local restrict_cexpr="`echo $restrict | build_expression compile`"
	local restrict_expr="`echo $restrict | build_expression compile run`"
	if [ "$count_selected_only" != "0" ]
	then
		local total_instances="`echo $restrict_expr | wc -w`"
	else
		local total_instances=`count_args ${compile[@]} ${run[@]}`
	fi

	local sp='/-\|'
	info_start Merging all results to $output_file ...

	## Take all column name and double quote them
	if [ "$dummy_compile" == "0" ]
	then
		echo ${compile[@]} ${run[@]} $output_columns | double_quotes > $output_file
	else
		echo ${run[@]} $output_columns | double_quotes > $output_file
	fi
		
	while [ "$#" != "0" ]
	do
		local input_dir=$1

		## Process this argument only if it is a directory
		if [ -d $input_dir ]
		then
			local counter=1
			while read flags
			do
				## If this instance id not part of the combination filtered with the restricted expression, then go directly to the next without even counting it
				#eval line=\"$flags\"
				#eval 'if ! ( ' $restrict_cexpr ' )
				#then
				#	continue
				#fi'
				if [ "$dummy_compile" != "0" ]
				then
					flags=""
				fi

				while read args
				do
					eval line=\"$flags $args\"
					eval 'if ! ( ' $restrict_expr ' )
					then
						counter=$(($counter + 1))
						echo -en '"'"'\r'"'"'
						echo -n "[INFO]" Merging all results to $output_file ... $(( $counter * 100 / $total_instances ))%\ 
						printf '"'"' \b%.1s'"'"' "$sp"
						sp=${sp#?}${sp%???}
						continue
					fi'
					#if [ "`cat $temp/freja.$$.restricted|cut -f 2 -d :|grep "^$flags $args$"`" == "" ]
					#then
					#	continue
					#fi

					filename=$input_dir/${output_base}_$(echo $flags $args|tr ' ' _|tr -d '"'|tr '/' '%')_${output_success}${output_extension}
					if [ -f ${filename} ]
					then
						cat $filename | tail -n +2 | sed "s/^/`echo $flags $args|commas`,/g" >> $output_file
					fi
					counter=$(($counter + 1))
					echo -en '\r'
					echo -n '[INFO]' Merging all results to $output_file ... $(( $counter * 100 / $total_instances ))%\ 
					printf ' \b%.1s' "$sp"
					sp=${sp#?}${sp%???}
				done < <(build_values ${run[@]})
			done < <(build_values ${compile[@]})
			
			echo -en '\r'
			echo '[INFO]' Merging all results to $output_file ... done.'       '
		fi
	
		shift
	done

	if [ "$dummy_compile" != "0" ]
	then
		eval ${compile[0]}=""
	fi
}

compile()
{
	local total_instances=`count_args ${compile[@]}`

	if [ "$(echo $restrict_compile)" == "" ] && [ "$(echo $restrict)" != "" ]
	then
		restrict_compile="$restrict"
	fi

	if [ "$(echo $restrict_compile)" != "" ]
	then
		local restrict_expr="`echo $restrict_compile | build_expression compile`"
		if [ "$count_selected_only" != "0" ]
		then
			info_start Processing batch list. This can take a while ...\ 
			local restrict_instances="`build_args ${compile[@]} | grep -n '' | while read line
			do
				eval 'if' $restrict_expr '
				then
					echo $line
				fi'
			done | tee $temp/freja.$$.restricted.compile | cut -f 1 -d :|tr \\\n ' '|xargs echo`"
			local restrict_instances="`echo $restrict_instances | wc -w`"
			info_stop done.
		else
			local restrict_instances=$total_instances
		fi
	else
		local restrict_instances=$total_instances
	fi

	info Will compile $restrict_instances settings

        ## Do not do anything if there is no instance to compile
        if [ "$total_instances" == "0" ]
        then
                exit 0
        fi

	local compile_counter=1

	# Success
	local compile_success=0

	# Timing
	local total_time=0

	local start_time=`date '+%s.%N'`
	build_args ${compile[@]} | while read args; do
		## If this instance id not part of the combination filtered with the restricted expression, then go directly to the next without even counting it
		if [ "$count_selected_only" != "0" ] && [ "`cat $temp/freja.$$.restricted.compile | cut -f 2 -d :|grep "^$args$"`" == "" ]
		then
			continue
		else
			eval line=\"$args\"
			if [ "$count_selected_only" == "0" ]
			then
				eval 'if ! ( ' $restrict_expr ' )
				then
					compile_counter=$(($compile_counter + 1))
					continue
				fi'				
			fi
		fi

		info_start Setting $compile_counter/$restrict_instances: `for i in $(seq 0 $((${#compile[@]} - 1)));do echo "${compile[$i]}=$(echo $args|cut -d ' ' -f $(($i + 1)))"; done`"... "
		instance_start=`date '+%s.%N'`
		bash $script_compile $args 2> >(cat | while read stderr; do silentlog $stderr; done) 1>&2 < /dev/null
		success=$?

		instance_stop=`date '+%s.%N'`

		if [ "x$success" == "x0" ]; then
			outcome="OK"
		else
			outcome="Failed"
			compile_success=1
		fi

		compile_time=$(echo $instance_stop - $instance_start | bc -l)
		#total_time=$(perl -e "printf(\"%.2f\", $(echo "($total_time + $compile_time)"))")
		total_time=$(echo $instance_stop - $start_time | bc -l)
		remaining=$(perl -e "printf(\"%.2f\", $(echo "(($total_instances - $compile_counter) * ($total_time / $compile_counter))"))")
		info_stop $outcome. $(printf "%.2f" $compile_time) sec finished on $(echo -n `get_date`)\; approx. $(printf "%.2f" $remaining) sec left \($(perl -e "printf(\"%.2f\", $(printf "%.2f" $(echo "($remaining / 60)" | bc -l)))") minutes\)

		if [ "x$compile_counter" == "x$restrict_instances" ]; then
			exit $compile_success
		fi

		compile_counter=$(($compile_counter + 1))
	done

	local compile_success=${PIPESTATUS[1]}
	if [ "x$compile_success" == "x0" ]; then
		local compile_outcome="Success"
	else
		local compile_outcome="Failed"
	fi
	
	local stop_time=`date '+%s.%N'`
	local overall_time=$(echo $stop_time - $start_time | bc -l)

	info $compile_outcome. Compilation took $(printf "%.2f" $overall_time) seconds \($(printf "%.2f" $(echo $overall_time / 60 | bc -l)) minutes\) or $(printf "%.2f" $(echo $overall_time / $total_instances | bc -l)) seconds per compilation setting \($(printf "%.2f" $(echo $overall_time / $total_instances / 60 | bc -l)) minutes\).

	return $compile_success
}

build_expression()
{
	#echo '['$0:$LINENO']' \$@ = \"$@\" >&2
	while [[ $# > 0 ]]
	do
		sources="$sources $1"
		shift
	done

	## Make sure we don't pattern match and eliminate nested parenthesis in the regular expression
	## Example on how to match balanced and nested parenthesis: 
	## http://stackoverflow.com/questions/14952113/how-can-i-matches-the-nested-brackets-by-regex
	#perl -i -pe 's/match\(([^,]*),(?:(\(([^()]|(?2))*\))|([^()]*))\)/echo \$line | match "$1" "$2$4"'"$sources"'/g'
	#echo '['$0:$LINENO']' \$1 = \"$1\" >&2
	#echo '['$0:$LINENO']' \$2 = \"$2\" >&2
	#echo '['$0:$LINENO']' \$sources = \"$sources\" >&2
	#echo '['$0:$LINENO']' \$dummy_compile = \"$dummy_compile\" >&2
	#perl -pe 's/match\(([^,]*)\s*,\s*"([^"]*)"\)/echo \$line | match "$1" "$2"'"$sources"' $dummy_compile/g'
	perl -pe 's/match\(([^,]*)\s*,\s*"([^"]*)"\)/echo \$line | match "$1" "$2" "$dummy_compile"'"$sources"'/g' #| tee /dev/stderr
}

batch()
{
	local run_instances=`count_args ${run[@]}`
	local compile_instances=`count_args ${compile[@]}`
        local dummy_compile=0

        ## If there is no compilation setting, just let the running settings go once
        if [ "$compile_instances" == "0" ]
        then
                compile_instances=1
		compile="nothing_$$"
                eval ${compile[0]}=1
                dummy_compile=1
        fi

	local restrict_expr="`echo $restrict | build_expression compile run`"
	if [ "$count_selected_only" != "0" ]
	then
		info_start Processing batch list. This can take a while ...\ 
		local restrict_instances="`build_args ${compile[@]} ${run[@]} | grep -n '' | while read line
		do
			eval 'if' $restrict_expr '
			then
				echo $line
			fi'
		done | tee $temp/freja.$$.restricted | cut -f 1 -d :|tr \\\n ' '|xargs echo`"
		info_stop done.
		local total_instances="`echo $restrict_instances | wc -w`"
	else
		local total_instances=`count_args ${compile[@]} ${run[@]}`
	fi

	## If there was an expression defined to rerun only a few experiments
	retry_expr=`echo $retry_expr | build_expression compile run`
	if [ "$retry_expr" != "" ]
	then
		info_start Processing retry list. This can take a while ...\ 
		## Rebuild the filtering expression for for compile and run settings

		if [ "$count_selected_only" != "0" ]
		then
			## Make up the complete list of settings to run and filter them using the expression
			retry_numbers="`build_args ${compile[@]} ${run[@]} | grep -n ''| while read line
			do
				eval 'if' $retry_expr ' 
				then
					echo $line
				fi'
			done | cut -f 1 -d :|tr \\\n ' '|xargs echo`"
			info_stop done.
		fi
	fi

	if [ "$retry_only" != "1" ] || [ "count_selected_only" == "0" ]
	then
		info Will run $total_instances instances
	else
		info Will run `echo $retry_numbers | wc -w` instances
	fi

        ## Do not do anything if there is no instance to compile or run
        if [ "$total_instances" == "0" ]
        then
                exit 0
        fi

	## Initialize the instance runing counter
	local instance_number=0
	
	# Initialize output file
	local start_time=`date '+%s.%N'`
	local output_dir=$experiment/$output_dir_current

	local batch_success=0
	local compile_counter=0
	local batch_time=0
	local skipped=0
	local filtered_counter=0

	while read flags
	do
		local run_counter=1
		local run_success=0
                if [ "$dummy_compile" != "0" ]
                then
                        flags=
                fi

		while read args
		do
			## If this instance id not part of the combination filtered with the restricted expression, then go directly to the next without even counting it
			if [ "$count_selected_only" != "0" ] && [ "`cat $temp/freja.$$.restricted|cut -f 2 -d :|grep "^$flags $args$"`" == "" ]
			then
				filtered_counter=$(( $filtered_counter + 1 ))
				continue
			fi

			## If the test above was passed, then count this instance
			local instance_number=$(($instance_number + 1))

			if [ "$count_selected_only" == "0" ]
			then
				eval line=\"$flags $args\"
				eval 'if ! ( ' $restrict_expr ' )
				then
					continue
				fi'				
			fi
	
			## If this instance has been cut through the retry option, then skip it (while still counting it)
			if [ "$retry_only" != "" ] && [ "`echo $retry_numbers|tr \\\t ' '|tr -s ' '|xargs echo|tr ' ' \\\n|grep ^$(($instance_number + $filtered_counter))$`" == "" ]
			then
				run_counter=$(($run_counter + 1))
				continue
			else
				:
			fi
			if [ "$dummy_compile" == "0" ]
                        then
				info_start Instance $instance_number/$total_instances: `for i in $(seq 0 $((${#compile[@]} - 1)));do echo "${compile[$i]}=$(echo $flags|cut -d ' ' -f $(($i + 1))) "; done``for i in $(seq 0 $((${#run[@]} - 1)));do echo "${run[$i]}=$(echo $args|cut -d ' ' -f $(($i + 1)))"; done`"... "
                        else
				info_start Instance $instance_number/$total_instances: `for i in $(seq 0 $((${#run[@]} - 1)));do echo "${run[$i]}=$(echo $args|cut -d ' ' -f $(($i + 1)))"; done`"... "
                        fi
			local instance_start=`date '+%s.%N'`
			#local args_index=`index_seq run $args`
			local instance_name="`echo $flags $args|tr ' ' _|tr '/' '%'`"
			local basename=${output_base}_${instance_name}

			## Only run this experiment if there is no output for this one
			#if [ -f $output_dir/${basename}_$output_success$output_extension ] && [ "`echo $retry_numbers|tr \\\t ' '|tr -s ' '|xargs echo|tr ' ' \\\n|grep ^$(($instance_number + filtered_counter))$`" == "" ]
			eval line=\"$flags $args\"

			if [ "$retry_expr" == "" ]
			then
				retry_expr_dummy=/bin/true
			else
				retry_expr_dummy="$retry_expr"
			fi

			eval 'if ( [ -f $output_dir/${basename}_$output_success$output_extension ] && [ "$retry_numbers" == "" ] && [ "$retry_expr" == "" ] ) || ( [ "$retry_numbers" != "" ] && [ "`echo $retry_numbers|tr \\\t " "|tr -s " "|xargs echo|tr " " \\\n|grep ^$(($instance_number + filtered_counter))$`" == "" ] ) || ( [ "$retry_expr" != "" ] && ! ( '$retry_expr_dummy' ) )
			then
				local outcome="Skipped"
				local skipped=$(($skipped + 1))
			else
				## Output the experiment output header
				## Reduces tabs and spaces to a single space, turn them to commas and frame them with double quotes
				echo $output_columns | double_quotes > $output_dir/${basename}_$output_progress$output_extension
				bash $script_run $flags $args 2> >(cat | while read stderr; do silentlog $stderr; done >&2) < /dev/null | while read line;
				do
					## Replace single quotes with double quotes, insert commas between fields
					echo $line | commas >> $output_dir/${basename}_$output_progress$output_extension
				done

				local success=${PIPESTATUS[0]}
				if [ "x$success" == "x0" ]; then
					local outcome="OK"
					mv $output_dir/${basename}_$output_progress$output_extension $output_dir/${basename}_$output_success$output_extension
				else
					local outcome="Failed"
					## Annotate output as failed
					## Create a numeric suffix in case of successive failures
					local num=`ls $output_dir/${basename}_${output_failure}*$output_extension 2> /dev/null | wc -l`
					if [ "$num" == "0" ]
					then
						num=""
					else
						num=_$num
					fi

					mv $output_dir/${basename}_${output_progress}$output_extension $output_dir/${basename}_${output_failure}$num$output_extension

					run_success=1
				fi
			fi'

			local instance_stop=`date '+%s.%N'`

			## Evaluate how much time is left before completion based on average time to run previous experiments, not taking into account the ones skipped
			local run_time=`echo $instance_stop - $instance_start | bc -l`
			total_run=$(($instance_number - $skipped))
			if [ "$total_run" == "0" ]
			then
				total_run=1
			fi
			#local batch_time=$(perl -e "printf(\"%.2f\", $(echo "($batch_time + $run_time)"))")
			local batch_time=`echo $instance_stop - $start_time | bc -l`
			local remaining=$(perl -e "printf(\"%.2f\", $(echo "(($total_instances - $instance_number) * ($batch_time / $total_run))"))")
			info_stop $outcome. $(printf "%.2f" $run_time) sec finished on $(echo -n `get_date`)\; approx. $(printf "%.2f" $remaining) sec left \($(perl -e "printf(\"%.2f\", $(printf "%.2f" $(echo "($remaining / 60)" | bc -l)))") minutes\)

			run_counter=$(($run_counter + 1))
		done < <(build_args ${run[@]})

		if [ "x$run_success" == "x0" ]; then
			local outcome="OK"
		else
			local outcome="Failed"
			local batch_success=1
		fi

		local compile_counter=$(($compile_counter + 1))
	done < <(build_args ${compile[@]})

	if [ "x$batch_success" == "x0" ]; then
		local batch_outcome="Success"
	else
		local batch_outcome="Failed"
	fi

	## If there was no real compile setting, reset the value to nothing
	if [ "$dummy_compile" == "1" ]
        then
		eval ${compile[0]}=
	fi

	local stop_time=`date '+%s.%N'`
	local overall_time=$(echo $stop_time - $start_time | bc -l)

	info $batch_outcome. Batch took $(printf "%.2f" $overall_time) seconds \($(printf "%.2f" $(echo $overall_time / 60 | bc -l)) minutes\) to run, or $(printf "%.2f" $(echo $overall_time / $total_instances | bc -l)) seconds per instance run \($(printf "%.2f" $(echo $overall_time / $total_instances / 60 | bc -l)) minutes\).

	return $batch_success
}

match()
{
	#echo '['$0:$LINENO']' \$@ = \"$@\"
	local variable="$1"
	local expression="$2"
	local dummy_compile="$3"
	shift 3

	if [ "$expression" == "" ]
	then
		expression=".*"
	fi

	while [[ $# > 0 ]]
	do
		local vars="$vars "'${'"$1"'[@]} '
		shift
	done
	#echo '['$0:$LINENO']' vars = \"$vars\"
	local index=`eval echo $vars | tr \\\t ' ' | tr -s ' ' | tr ' ' \\\n | xargs -L 1 echo | grep -n ^$variable$ | cut -f 1 -d :`
	if [ "$dummy_compile" == "1" ]
	then
		index=$(($index - 1))
	fi

	if [ "$index" == "" ]
	then
		warning Could not 'find' variable \"$variable\" >&2 when building filtering expression
		return 1
	fi

	read line
	if [ "`echo $line | cut -f 1 -d : --complement | cut -f $index -d ' ' | sed '/'"$expression"'/!d'`" != "" ]
	then
		return 0
	else
		return 1
	fi
}

compile-test()
{
	shift
	if [ "$#" != "`echo ${compile[@]} | wc -w`" ]
	then
		echo Incorrect number of settings. Please give the value of each compilation parameter as arguments in the form key=value. >&2
		echo ex. freja compile-test hello=world foo=bar >&2
		echo >&2
		echo Values required: ${compile[@]} >&2
		echo Value defined: $@ >&2
		echo >&2
		exit 1
	fi
	bash $script_compile $(:(){ paste $@; };: <(echo ${compile[@]} | tr ' ' \\\n | grep -n "" | sort -t : -k2) <(echo $@ | tr ' ' \\\n | sort -t = -k1) | sort -t: -k1 -V | cut -f 2 -d = | xargs echo)
}

run-test()
{
	shift
	if [ "$#" != "`echo ${compile[@]} ${run[@]} | wc -w`" ]
	then
		echo Incorrect number of settings. Please give the value of each compilation and run parameter as arguments in the form key=value. >&2
		echo ex. freja run-test hello=world foo=bar >&2
		echo >&2
		echo Values required: ${compile[@]} ${run[@]}>&2
		echo Value defined: $@ >&2
		echo >&2
		exit 1
	fi
	bash $script_run $(:(){ paste $@; };: <(echo ${compile[@]} ${run[@]} | tr ' ' \\\n | grep -n "" | sort -t : -k2) <(echo $@ | tr ' ' \\\n | sort -t = -k1) | sort -t: -k1 -V | cut -f 2 -d = | xargs echo)
}

parse_options()
{
	operation=$1
	shift

	## First catch the operation and experiment names
	case "$operation" in
		"compile" | "sources")
			:
		;;
		"compile-test" | "run-test")
			return 0
		;;
		"run" | "merge")
			experiment="$1"
			shift

			if [ "$experiment" == "" ]
			then
				error You must name the experiment to be run
				usage
				exit 1
			fi
		;;
		"fuse")
			column=$1
			shift

			if [ "$column" == "" ] || [ "`echo $column | grep ^--`" != "" ]
			then
				error You must specify a column name to fuse two experiments
				usage
				exit 1
			fi

			## Default output file
			output_file=frame.csv
		;;
		"convert")
			input_file="$1"
			shift

			if [ "$input_file" == "" ] || [ ! -f "$input_file" ]
			then
				error Invalid file or file not found: \"$input_file\"
				exit 1
			fi

			## Default output file
			output_file=table.m
		;;
		"label")
			## Valid operation, but nothing to do here
			:
		;;
		*)
			error Unknown operation
			usage

			exit 1	
		;;
	esac

	## Then parse all other options
	while [[ $# > 0 ]]
	do
		case "$1" in
			"--retry")
				shift
				case "$1" in
					"--pattern" | "-p")
						shift
						retry_expr="$1"

					;;
					"--number" | "-n")
						shift
						retry_numbers="$1"
					;;
					"--all" | "-a")
						retry_expr='/bin/true' ## An expression that returns true for all experiments.
					;;
					"")
						## If an empty parameter for the filtering method manages to reach here,
						## Let it go, do nothing and catch the error later
						:
					;;
					*)
						error Unknown experiment description method: \"$1\"
						usage
						exit 1
					;;
				esac

				## If no filtering option was given, give an error message and exit
				if [ "$retry_expr" == "" ] && [ "$retry_numbers" == "" ]
				then
					error You must specify a list of instances to run again
					usage
					exit 1
				fi
			;;
			"--retry-only")
				if [ "$retry_numbers" == "" ] && [ "$retry_expr" == "" ]
				then
					error Attempting to retry only an experiment list without defining it
					usage
					exit 1
				else
					retry_only=1
				fi
			;;
			"--instance")
				shift
				instance_name="`basename $1`"

				if [ -d $experiment/$instance_name ]
				then
					if [ "$instance_name" == "$output_dir_current" ]
					then
						error You cannot use \"$instance_name\" as an experiment instance name: conflicting name with the name of a experiment being run '('value of \"output_dir_current\" 'in' ~/.freja/settings')'
						exit 1
					fi

					if [ -d $experiment/$output_dir_current ] && [ "`basename $(ls -l $experiment/$output_dir_current | cut -f 2 -d '>' | xargs echo)`" != "$instance_name" ]
					then
						error There is already an ongoing instance of this experiment. Finish it or delete $experiment/$output_dir_current '('there will be no data loss')' and try again
						exit 1
					fi
				fi
			;;
			"--compile")
				shift
				script_compile="$1"
			;;
			"--run")
				shift
				script_run="$1"
			;;
			"--settings")
				shift
				script_settings="$1"
			;;
			"--variables")
				shift
				script_variables="$1"
			;;
			"--output")
				shift
				output_file="$1"

				if [ -f "$output_file" ]
				then
					error Output file \"$output_file\" already exist. Delete or move it and try again
					exit 1
				fi
			;;
			"--log")
				shift
				logfile="$1"
			;;
			"--count-selected-runs-only")
				count_selected_only=1
			;;
			"--")
				return 0
			;;
			*)
				error Unknown option: $1
				usage
				exit 1
			;;
		esac

		## Get to next argument
		shift
	done
}

## Catch exit events to clean up temporary files
## http://redsymbol.net/articles/bash-exit-traps/
finish() {
	rm -rf $temp
}
trap finish EXIT 

## Force decimal separator as a dot "." as in american english
export LC_NUMERIC="en_US.UTF-8"

## Fill up undefined options with default values
if [ "`echo $restrict|xargs echo`" == "" ]
then
	restrict=/bin/true
fi

script_compile=./compile
script_run=./run
script_variables=./variables

## Default settings values
table_name=table

temp=/tmp
columns_list_name=table_columns
symbol_list_name=table_symb
ref_list_name=table_ref
columns_file=$temp/pid.$$.columns
failed_file=$temp/pid.$$.failed
passed_file=$temp/pid.$$.passed
data=$table_name
ext=.csv
output_dir_current=current
output_extension=.csv
output_success=success
output_failure=failure
output_progress=progress
output_base=instance
labels_filename=labels.r
labels_snippet_filename=`dirname $0`/../share/freja/labels_snippet.r
count_selected_only=0

DATA_BEGIN="function x = $table_name()\\nx = {["
DATA_END="] $columns_list_name() $symbol_list_name() $ref_list_name()};\\nend\\n"

COLUMNS_BEGIN="function x = $columns_list_name()\\nx = {"
COLUMNS_END="\\n};\\nend\\n"

SYMB_BEGIN="function x = $symbol_list_name()\\nx = {"
SYMB_END="\\n};\\nend\\n"

REF_BEGIN="function x = $ref_list_name()\\nx = {"
REF_END="\\n};\\nend\\n"

failed_begin="==== Failed run ===="
failed_end="--------------------"

## Load environment setting files
if [ -f /etc/freja/settings ]
then
	. /etc/freja/settings
fi
if [ -f ~/.freja/settings ]
then
	. ~/.freja/settings
fi
if [ "$logfile" == "" ]
then
	logfile=/dev/null
fi
if [ "$temp" == "" ]
then
	temp=/tmp
fi
temp=$temp/freja.$$.tmp
default_temp="$temp"

experiment=""
operation=""

## Parse all options
eval parse_options `for i in "$@"; do printf "\"%s\" " "$(echo $i|sed 's/"/\\\"/g')"; done; echo`

if [ "$script_settings" != "" ]
then
	if [ ! -f $script_settings ]
	then
		error Cannot find settings file \"$script_settings\"
		exit 1
	else
		## Load global settings
		. $script_settings

		## Check if temp has been redefined; if so, add it a unique directory name
		if [ "$temp" != "$default_temp" ]
		then
			temp=$temp/freja.$$.tmp
		fi
	fi
fi

mkdir -p $temp
if [ "$logfile" != "" ]
then
	if [ -f "$logfile" ]
	then
		info > /dev/null
	fi
	info New run on `date` > /dev/null
fi

case "$operation" in
	"sources")
		if [ -f "$(dirname $(realpath $0))/../share/freja/freja.tar.gz" ]
		then
			ls $(dirname $(realpath $0))/../share/freja/freja.tar.gz | sort -rV | head -1 | xargs realpath
		fi
	;;
	"compile")
		eval load_variables `for i in "$@"; do printf "\"%s\" " "$(echo $i|sed 's/"/\\\"/g')"; done; echo`
		if [ ! -f $script_compile ]
		then
			error Cannot find compile script \"$script_compile\"
			exit 1
		fi
		compile
		exit $?
	;;
	"compile-test")
		eval load_variables `for i in "$@"; do printf "\"%s\" " "$(echo $i|sed 's/"/\\\"/g')"; done; echo`
		if [ ! -f $script_compile ]
		then
			exit 1
		fi
		eval compile-test `for i in "$@"; do printf "\"%s\" " "$(echo $i|sed 's/"/\\\"/g')"; done; echo`
		exit $?
	;;
	"run-test")
		eval load_variables `for i in "$@"; do printf "\"%s\" " "$(echo $i|sed 's/"/\\\"/g')"; done; echo`
		if [ ! -f $script_compile ]
		then
			exit 1
		fi
		eval run-test `for i in "$@"; do printf "\"%s\" " "$(echo $i|sed 's/"/\\\"/g')"; done; echo`
		exit $?
	;;
	"run")
		eval load_variables `for i in "$@"; do printf "\"%s\" " "$(echo $i|sed 's/"/\\\"/g')"; done; echo`
		if [ ! -f $script_run ]
		then
			error Cannot find run script \"$script_run\"
			exit 1
		fi

		## Sets a default instance name if no name was defined
		if [ "$instance_name" = "" ]
		then
			if [ -d $experiment/$output_dir_current ]
			then
				instance_name=`ls -l $experiment/current | cut -f 2 -d '>' | cut -f 2 -d ' '`
			else
				instance_name=`get_date_filename`
			fi
		fi

		## Create experiment and instance output directory, if necessary
		if [ ! -d "$experiment" ] || [ ! -d "$experiment/$instance_name" ]
		then
			mkdir -p "$experiment/$instance_name"
		fi

		## Create symbolic link to current experiment instance
		if [ ! -d "$experiment/$output_dir_current" ]
		then
			ln -s "$instance_name" "$experiment/$output_dir_current"
		fi

		batch
		batch_success=$?
	
		# Remove symbolic link upon success	
		if [ "$batch_success" == "0" ]
		then
			rm "$experiment/$output_dir_current"
		fi

		## Create a csv file from the experiment instance that was just run
		merge_dir "$experiment/$instance_name/$data$ext" "$experiment/$instance_name"
		## Merge all instances of this experiment into one single file
		merge_dir "$experiment/$data$ext" `ls -d "$experiment"/*`
		cp "$experiment/$data$ext" ./$output_file

		## Create an alias file
		build_aliases > $labels_filename

		exit $batch_success
	;;

	"merge")
		eval load_variables `for i in "$@"; do printf "\"%s\" " "$(echo $i|sed 's/"/\\\"/g')"; done; echo`
		merge_dir $experiment/$data$ext `ls -d $experiment/*`
		cp $experiment/$data$ext ./$output_file

		exit 0
	;;

	"label")
		eval load_variables `for i in "$@"; do printf "\"%s\" " "$(echo $i|sed 's/"/\\\"/g')"; done; echo`
		build_aliases > $labels_filename

		exit $?
	;;

	"fuse")
		## Skip all arguments until we finally find the list of files to fuse
		while [ "$1" != "--" ]
		do
			shift
		done
		shift

		## Take the header of the first file to merge
		cat $1 | head -1 | sed 's/^/"'$column'",/g' > $output_file

		## Merge several csv files into a third bigger, with an additional column
		counter=0
		while [[ $# > 0 ]]
		do
			cat $1 | tail -n +2 | sed 's/^/"'$counter'",/g' >> $output_file
			counter=$(( $counter + 1 ))
			shift
		done
	;;

	"convert")
		eval load_variables `for i in "$@"; do printf "\"%s\" " "$(echo $i|sed 's/"/\\\"/g')"; done; echo`

		convert_csv_to_m "$input_file" "$output_file"
		## Convert a csv file to a matlab-readable cell file
		:
	;;
esac

